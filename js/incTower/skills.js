define(['incTower/core', 'lib/knockout', 'lib/bignumber', 'lib/moment', 'lib/lodash', 'lib/ko.observableDictionary', 'lib/jstree', 'incTower/util',  'incTower/tooltips'], function (incTower, ko, BigNumber, moment, _) {
    'use strict';



    var humanizeNumber = incTower.humanizeNumber;
    incTower.skillAttributes = {
        construction: {
            fullName: 'Construction',
            baseCost: 20,
            growth: 1.1,
            describeRank: function (rank) {
                return 'Reduces the cost of towers and their upgrades by ' + rank + '%.';
            },
            maxLevel: 10,
            grants: {
                10: ['modularConstruction', 'initialEngineering']
            }
        },
        modularConstruction: {
            fullName: 'Modular Construction',
            baseCost: 135,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Reduces the cost of upgrading all towers by ' + (rank * 5) + '%.';
            },
            maxLevel: 5,
            grants: {
                5: ['adaptiveUpgrades']
            }
        },
        adaptiveUpgrades: {
            fullName: 'Adaptive Upgrades',
            baseCost: 120,
            growth: 1.25,
            describeRank: function (rank) {
                return "Each hit from a tower now reduces its upgrade cost by " + (rank * 0.1) + "% of the monster's gold value. Towers will automatically upgrade when their upgrade cost reaches zero.";
            },
            maxLevel: 10
        },
        initialEngineering: {
            fullName: 'Initial Engineering',
            baseCost: 135,
            growth: 1.15,
            describeRank: function (rank) {
                return 'Increases the starting damage, attack speed, and range for all towers by ' + (rank * 5) + '%.';
            },

            maxLevel: 5,
            grants: {
                5: ['towerTemplates', 'scrapping']
            }
        },
        towerTemplates: {
            fullName: 'Tower Templates',
            baseCost: 900,
            growth: 2,
            describeRank: function (rank) {
                'use strict';
                return 'Allows you to create blueprints from existing towers, increasing the base damage of that type of tower.';
            },
            maxLevel: 1,
            grants: {
                1: ['refinedBlueprints']
            },
            onMax: function () {
                incTower.addToObsArray(incTower.availableActions, 'template');
            }
        },
        scrapping: {
            fullName: 'Scrapping',
            baseCost: 80,
            growth: 1.5,
            describeRank: function (rank) {
                return 'Refunds an additional ' + (rank * 5) + '% of gold spent after the sale of a tower.';
            },
            maxLevel: 5
        },
        refinedBlueprints: {
            fullName: 'Refined Blueprints',
            baseCost: 15,
            growth: 1.2,
            describeRank: function (rank) {
                return 'Increases the number of blueprint points generated by creating a template by ' + (rank * 5) + '%.';
            },
        },
        marketConnections: {
            fullName: 'Market Connections',
            baseCost: 45,
            growth: 1.2,
            describeRank: function (rank) {
                return 'Increases the gold reward on each kill by ' + (rank) + '%.';
            }


        },
        kineticTowers: {
            fullName: 'Kinetic Towers',
            baseCost: 20,
            growth: 1.1,
            maxLevel: 10,
            describeRank: function (rank) {
                return 'Increases the damage that kinetic towers deal by ' + (5 * rank) + '%.';
            },
            grants: {
                10: ['shrapnelAmmo', 'kineticAmmo']
            }
        },
        shrapnelAmmo: {
            fullName: 'Shrapnel Ammo',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                return 'Allows your kinetic towers to be equipped with shrapnel rounds which will do less damage initially but will always cause bleeding.';
            },
            grants: {
                1: ['anticoagulants']
            },
            onMax: function () {
                incTower.addToObsArray(incTower.towerAttributes.kinetic.ammoTypes, 'shrapnel')
            }
        },
        anticoagulants: {
            fullName: 'Anti-Coagulants',
            baseCost: 20,
            growth: 2.386,
            describeRank: function (rank) {
                if (rank < 10) {
                    return 'Bleeding is reduced by ' + (50 - 5 * rank) + '% each tick instead of the base 50%.';
                }
                if (rank === 10) {
                    return 'Bleeding is no longer reduced over time.';
                }
                if (rank > 10) {
                    return 'Instead of bleed damage being reduced it is increased by ' + (rank * 5) + '%.';
                }
            }
        },
        kineticAmmo: {
            fullName: 'Kinetic Ammo',
            baseCost: 15,
            growth: 1.1,
            describeRank: function (rank) {
                return 'Optimizes the damage caused by kinetic towers, increasing damage by ' + (rank * 5) + '%.';
            }
        },
        magicalAffinity: {
            fullName: 'Magical Affinity',
            baseCost: 120,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function () {
                return "Grants magical affinity opening the path to casting spells and elemental towers.";
            },
            onMax: function () {
                if (incTower.rawMaxMana().eq(0)) {
                    incTower.rawMaxMana(new BigNumber(1000));
                    incTower.mana(incTower.maxMana());
                }
                incTower.addToObsArray(incTower.availableSpells, 'manaBurst');
                incTower.addToObsArray(incTower.availableSpells, 'arcaneSacrifice');


            },
            grants: {
                1: ['fireAffinity', 'waterAffinity', 'earthAffinity', 'airAffinity', 'wizardry']
            }
        },
        wizardry: {
            fullName: 'Wizardry',
            baseCost: 60,
            growth: 1.2,
            maxLevel: 5,
            describeRank: function (rank) {
                'use strict';
                return "Increases arcane damage by " + (rank * 10) + '%.';
            },
            grants: {
                1: ['manaRegeneration', 'arcaneKnowledge']
            }
        },
        manaRegeneration: {
            fullName: 'Mana Regeneration',
            baseCost: 30,
            growth: 1.2,
            describeRank: function (rank) {
                return "Increases mana regeneration by " + rank + ' per second.';
            },
            grants: {
                20: ['manaRegenerationAdvanced']
            }
        },
        manaRegenerationAdvanced: {
            fullName: 'Mana Regeneration (Advanced)',
            baseCost: 40,
            growth: 1.3,
            describeRank: function (rank) {
                return "Increases mana regeneration by " + (rank * 5) + '%.';
            }
        },
        arcaneKnowledge: {
            fullName: 'Arcane Knowledge',
            baseCost: 30,
            growth: 1.2,
            describeRank: function (rank) {
                return "Increases max mana by " + (rank * 5) + '%.';
            }
        },
        fireAffinity: {
            fullName: 'Fire Affinity',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                return "Attunes yourself with fire which allows you to build fire towers which burn enemies over time, causing them to take increased damage from all sources.";
            },
            onMax: function () {
                incTower.addToObsArray(incTower.availableTowers, 'fire');
                incTower.addToObsArray(incTower.availableSpells, 'smolder');
            },
            grants: {
                1: ['fireRuneApplication', 'fireMastery']
            }
        },
        fireMastery: {
            fullName: 'Fire Mastery',
            baseCost: 100,
            growth: 1.266,
            describeRank: function (rank) {
                'use strict';
                return "Increases all fire damage dealt by " + (rank * 10) + '%.';
            },
        },

        fireRuneApplication: {
            fullName: 'Fire Rune Application',
            baseCost: 100,
            growth: 1.266,
            maxLevel: 10,
            describeRank: function (rank) {
                'use strict';
                return "Increases the chance that a fire tower successfully applies a rune by " + (rank * 5) + '%.';
            },
            grants: {
                10: ['fireAdvancedRuneApplication']
            }
        },
        fireAdvancedRuneApplication: {
            fullName: 'Fire Rune Application (Advanced)',
            baseCost: 200,
            growth: 1.406,
            maxLevel: 10,
            describeRank: function (rank) {
                return "When a fire tower successfully applies a rune, there is a " + (rank * 5) + '% chance that it will apply two instead.';
            }
        },
        waterAffinity: {
            fullName: 'Water Affinity',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                'use strict';
                return "Attunes yourself with water which allows you to build water towers which slow and freeze enemies.";
            },

            onMax: function () {
                'use strict';
                incTower.addToObsArray(incTower.availableTowers, 'water');
                incTower.addToObsArray(incTower.availableSpells, 'frostShatter');
            },
            grants: {
                1: ['waterRuneApplication', 'waterMastery']
            }
        },
        waterMastery: {
            fullName: 'Water Mastery',
            baseCost: 100,
            growth: 1.266,
            describeRank: function (rank) {
                'use strict';
                return "Increases all water damage dealt by " + (rank * 10) + '%.';
            },
        },
        waterRuneApplication: {
            fullName: 'Water Rune Application',
            baseCost: 100,
            growth: 1.266,
            maxLevel: 10,
            describeRank: function (rank) {
                'use strict';
                return "Increases the chance that a water tower successfully applies a rune by " + (rank * 5) + '%.';
            },
            grants: {
                10: ['waterAdvancedRuneApplication']
            }
        },
        waterAdvancedRuneApplication: {
            fullName: 'Water Rune Application (Advanced)',
            baseCost: 200,
            growth: 1.406,
            maxLevel: 10,
            describeRank: function (rank) {
                'use strict';
                return "When a water tower successfully applies a rune, there is a " + (rank * 5) + '% chance that it will apply two instead.';
            }
        },

        earthAffinity: {
            fullName: 'Earth Affinity',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                'use strict';
                return "Attunes yourself with earth which allows you to build earth towers which drop giant boulders from the sky, causing area of effect damage.";
            },

            onMax: function () {
                incTower.addToObsArray(incTower.availableTowers, 'earth');
                incTower.addToObsArray(incTower.availableSpells, 'seismicRupture');

            },
            grants: {
                1: ['earthRuneApplication', 'earthMastery']
            }

        },
        earthMastery: {
            fullName: 'Earth Mastery',
            baseCost: 100,
            growth: 1.266,
            describeRank: function (rank) {
                'use strict';
                return "Increases all earth damage dealt by " + (rank * 10) + '%.';
            },
        },

        earthRuneApplication: {
            fullName: 'Earth Rune Application',
            baseCost: 100,
            growth: 1.266,
            maxLevel: 10,
            describeRank: function (rank) {
                return "Increases the chance that an earth tower successfully applies a rune by " + (rank * 5) + '%.';
            },
            grants: {
                10: ['earthAdvancedRuneApplication']
            }
        },
        earthAdvancedRuneApplication: {
            fullName: 'Earth Rune Application (Advanced)',
            baseCost: 200,
            growth: 1.406,
            maxLevel: 10,
            describeRank: function (rank) {
                return "When an earth tower successfully applies a rune, there is a " + (rank * 5) + '% chance that it will apply two instead.';
            },
        },

        airAffinity: {
            fullName: 'Air Affinity',
            baseCost: 900,
            growth: 1.1,
            maxLevel: 1,
            describeRank: function (rank) {
                'use strict';
                return "Attunes yourself with air which allows you to build air towers which will occasionally trap enemies in a whirlwind, knocking them back.";
            },

            onMax: function () {
                incTower.addToObsArray(incTower.availableTowers, 'air');
                incTower.addToObsArray(incTower.availableSpells, 'eyeOfTheStorm');
            },
            grants: {
                1: ['airRuneApplication', 'airMastery']
            }
        },
        airMastery: {
            fullName: 'Air Mastery',
            baseCost: 100,
            growth: 1.266,
            describeRank: function (rank) {
                'use strict';
                return "Increases all air damage dealt by " + (rank * 10) + '%.';
            },
        },
        airRuneApplication: {
            fullName: 'Air Rune Application',
            baseCost: 100,
            growth: 1.266,
            maxLevel: 10,
            describeRank: function (rank) {
                'use strict';
                return "Increases the chance that an air tower successfully applies a rune by " + (rank * 5) + '%.';
            },

            grants: {
                10: ['airAdvancedRuneApplication']
            }
        },
        airAdvancedRuneApplication: {
            fullName: 'Air Rune Application (Advanced)',
            baseCost: 200,
            growth: 1.406,
            maxLevel: 10,
            describeRank: function (rank) {
                'use strict';
                return "When an air tower successfully applies a rune, there is a " + (rank * 5) + '% chance that it will apply two instead.';
            },
        },
        sensors: {
            fullName: 'Sensors',
            baseCost: 30,
            growth: 1.2,
            describeRank: function (rank) {
                'use strict';
                return 'Increases tower range by ' + (rank * 5) + '%.';
            },
            maxLevel: 5,
            grants: {
                5: ['sensorArrays']
            }
        },
        sensorArrays: {
            fullName: 'Sensor Arrays',
            baseCost: 900,
            growth: 1.2,
            describeRank: function (rank) {
                return 'Allows the construction of sensor arrays which periodically increase the range of towers adjacent to them.';
            },
            maxLevel: 1,
            onMax: function () {
                incTower.addToObsArray(incTower.availableTowers, 'sensor');
            }
        }

    };

    incTower.skills = ko.observableDictionary({});
    incTower.skillQueue = ko.observableArray([]);
    incTower.clearQueue = function () {
        'use strict';
        while (incTower.skillQueue().length > 0) {
            incTower.skillQueue.shift();
        }
    };
    incTower.UIselectedSkill = ko.observable(false);
    incTower.activeSkill = ko.pureComputed(function () {
        'use strict';
        if (incTower.skillQueue().length === 0) {
            return false;
        }
        return incTower.skillQueue()[0][0];
    });
    incTower.skillQueue.subscribe(function () {
        //Whenever the active skill changes make sure our tooltip updates
        incTower.checkTooltips();
    });
    incTower.getSkillTreeLabel = function (skillName) {
        var maxLevel = incTower.skillAttributes[skillName].maxLevel;
        if (maxLevel === undefined) {
            maxLevel = '&infin;';
        }
        var currentLevel = '--';
        var stars = '';
        if (incTower.haveSkill(skillName)) {
            currentLevel = incTower.getSkillLevel(skillName);
            stars = _.repeat('&#9733;', Math.floor(currentLevel / 20));
        }
        return incTower.skillAttributes[skillName].fullName + stars + ' (' + currentLevel + ' / ' + maxLevel + ')';
    };
    incTower.skillTreeUpdateLabel = function (skillName) {
        $('#skills_tree').jstree('rename_node', '#' + skillName, incTower.getSkillTreeLabel(skillName));
    };
    incTower.skillTreeMode = ko.observable('tree');
    incTower.skillTreeMode.subscribe(function (newVal) {
       if (newVal === 'flat') {
           $('#skills_tree').jstree(true).settings.core.data = incTower.skillTreeDataFlat();
           $('#skills_tree').jstree(true).refresh();
       } else {
           $('#skills_tree').jstree(true).settings.core.data = incTower.skillTreeData();
           $('#skills_tree').jstree(true).refresh();
       }
    });
    incTower.checkQueue = function () {
        'use strict';
        while (true) {
            if (incTower.skillQueue().length === 0) {
                break;
            }
            var firstItem = incTower.skillQueue()[0];
            if (incTower.getSkillLevel(firstItem[0]) !== firstItem[1] - 1) {
                incTower.skillQueue.shift();
            } else {
                break;
            }
        }
        if (!incTower.activeSkill() || !_.has(incTower.skillAttributes, incTower.activeSkill())) {
            if (incTower.skillQueue().length === 0) {
                var skills = incTower.skills.keys();
                incTower.shuffle(skills);
                incTower.enqueueSkill(_.find(skills, function (skill) {
                    return incTower.directlyQueueable(skill);
                }));
            }
            //incTower.activeSkill(incTower.skillQueue()[0][0]);
        }

    };
    incTower.skillHasMax = function (skillName) {
        'use strict';
        return incTower.skillAttributes[skillName].maxLevel !== undefined;
    };
    incTower.skillGetPrereq = function (skillNameToFind) {
        'use strict';
        if (incTower.skillAttributes[skillNameToFind].prereq) {
            return incTower.skillAttributes[skillNameToFind].prereq;
        }
        if (_.includes(incTower.startingSkills, skillNameToFind)) {
            incTower.skillAttributes[skillNameToFind].prereq = false;
            return false;
        }
        var ret;
        _.forEach(_.keys(incTower.skillAttributes), function (skill) {
            if (incTower.skillAttributes[skill].grants === undefined) {
                return;
            }
            _.mapValues(incTower.skillAttributes[skill].grants, function (skills, level) {
                if (_.includes(skills, skillNameToFind)) {
                    ret = [skill, parseInt(level)];
                    incTower.skillAttributes[skillNameToFind].prereq = ret;
                    return false;
                }
            });
        });
        return ret;
    };
    incTower.skillIsMaxed = function (skillName) {
        'use strict';
        if (!skillName) {
            return false;
        }
        if (incTower.skillHasMax(skillName)) {
            if (incTower.getSkillLevel(skillName) >= incTower.skillAttributes[skillName].maxLevel) {
                return true;
            }
        }
        return false;
    };

    incTower.skillRankInQueue = function (skill) {
        'use strict';
        var minRank = 0;
        _.map(incTower.skillQueue(), function (item) {
            if (item[0] === skill) {
                minRank = item[1];
            }
        });
        return minRank;
    };
    incTower.skillMaxedInQueue = function (skill) {
        'use strict';
        if (!skill) {
            return false;
        }
        var minRank = incTower.skillRankInQueue(skill) + 1;
        if (incTower.skillAttributes[skill].maxLevel !== undefined && minRank > incTower.skillAttributes[skill].maxLevel) {
            return true;
        }
        return false;
    };
    incTower.directlyQueueable = function (skill) {
        'use strict';
        if (!(skill in incTower.skillAttributes)) {
            return false;
        }
        //Returns the rank trainable in the skill if it is directly trainable, meaning all prereqs are met in the queue already, otherwise false
        var minRank = Math.max(incTower.getSkillLevel(skill), incTower.skillRankInQueue(skill)) + 1;

        if (incTower.skillAttributes[skill].maxLevel !== undefined && minRank > incTower.skillAttributes[skill].maxLevel) {
            return false;
        }
        if (!incTower.haveSkill(skill)) {
            var grants = [];
            _.map(incTower.skillQueue(), function (item) {
                var skill = item[0];
                var rank = item[1];
                if (incTower.skillAttributes[skill].grants !== undefined) {
                    _.mapValues(incTower.skillAttributes[skill].grants, function (skills, level) {
                        if (rank >= level) {
                            grants = grants.concat(skills);
                        }
                    });
                }
            });
            if (!_.includes(grants, skill)) {
                return false;
            }
        }
        return minRank;
    };
    incTower.directlyRemovable = function (skill, rank) {
        'use strict';
        var removable = true;
        var possGrants = incTower.possibleGrants(skill, rank);
        _.forEach(incTower.skillQueue(), function (item) {
            if (item[0] === skill && item[1] === rank + 1) {
                removable = false;
                return false;
            }
            if (_.includes(possGrants, item[0])) {
                removable = false;
                return false;
            }


        });
        return removable;
    };
    incTower.enqueueSkill = function (skill) {
        'use strict';
        var minRank = incTower.directlyQueueable(skill);
        if (minRank === false) {
            return false;
        }
        incTower.skillQueue.push([skill, minRank]);
    };
    incTower.skillCanTrain = function (skillName) {
        'use strict';
        if (incTower.skillIsMaxed(skillName)) {
            return false;
        }
        if (incTower.activeSkill() === skillName) {
            return false;
        } //Can't train the skill you're already training
        return true;
    };
    incTower.skillTextProgress = function (skillName) {
        'use strict';
        if (incTower.skillAttributes[skillName] === undefined) {
            return "";
        }
        var skill = incTower.skills.get(skillName)();
        if (skill === null) {
            return "";
        }
        //if (skill.get('skillPoints')() === null) { return ""; }
        if (incTower.skillIsMaxed(skillName)) {
            return "Maxed";
        }
        return humanizeNumber(skill.get('skillPoints')()) + " / " + humanizeNumber(skill.get('skillPointsCap')());
    };

    incTower.startingSkills = ['kineticTowers', 'construction', 'magicalAffinity', 'sensors'];
    incTower.gainSkill = function (name, opt) {
        'use strict';
        if (typeof opt === 'undefined') {
            opt = {};
        }
        if (!(name in incTower.skillAttributes)) {
            console.log(name + " is not in our skills list.");
        }
        /*if (incTower.getSkillLevel(name) !== -1) { return; } //We already know the skill*/
        //Either gains a new skill at level 1 or loads in a previously saved skill
        var skillLevel = opt.skillLevel || 0;
        var skillPoints = new BigNumber(opt.skillPoints || 0);
        var skillPointsCap = incTower.costCalc(incTower.skillAttributes[name].baseCost, skillLevel, incTower.skillAttributes[name].growth);
        incTower.skills.push(name, ko.observableDictionary({
            skillLevel: skillLevel,
            skillPoints: skillPoints,
            skillPointsCap: skillPointsCap
        }));
        incTower.checkSkill(name);
        //incTower.skillTreeUpdateLabel(name);
    };
    incTower.describeSkill = function (name) {
        'use strict';
        if (!(name in incTower.skillAttributes)) {
            return '';
        }
        var currentLevel = incTower.getSkillLevel(name);
        var desc = '';
        var maxed = incTower.skillIsMaxed(name);
        if (currentLevel > 0) {
            desc += "<p>" + incTower.skillAttributes[name].describeRank(incTower.levelToEffective(currentLevel)) + '</p>';
        }
        if (!maxed) {
            desc += '<p>Next Rank: ' + incTower.skillAttributes[name].describeRank(incTower.levelToEffective(currentLevel + 1)) + '</p>';
        }
        var grants = incTower.skillAttributes[name].grants;
        if (grants !== undefined) {
            _.mapValues(grants, function (skills, level) {
                var fullSkillNames = _.map(skills, function (skill) {
                    return incTower.skillAttributes[skill].fullName;
                });
                fullSkillNames = incTower.prettyCommaList(fullSkillNames);
                desc += '<p>Grants ' + fullSkillNames + ' at level ' + level + '.</p>';

            });

        }
        return desc;
    };
    incTower.getSkillLevel = function (name) {
        'use strict';
        if (incTower.skills.get(name)() === null) {
            return 0;
        }
        return incTower.skills.get(name)().get('skillLevel')();
    };
    incTower.getEffectiveSkillLevel = function (name) {
        return incTower.levelToEffective(incTower.getSkillLevel(name));
    };
    incTower.levelToEffective = function (skillLevel) {
        return skillLevel * Math.pow(2, Math.floor(skillLevel / 20));
    };
    incTower.possibleGrants = function (skill, atLevel) {
        'use strict';
        if (atLevel === undefined) {
            return _.flatten(_.values(incTower.skillAttributes[skill].grants));
        }
        var grants = [];
        _.mapValues(incTower.skillAttributes[skill].grants, function (skills, level) {
            if (atLevel >= level) {
                grants = grants.concat(skills);
            }
        });
        return grants;
    };
    incTower.checkSkills = function () {
        _.map(incTower.skills.keys(), incTower.checkSkill);
    };
    incTower.checkSkill = function (skill) {
        //console.log("CHECK : " + skill);
        var toAdd = [];
        if (incTower.skillAttributes[skill].maxLevel !== undefined && incTower.getSkillLevel(skill) > incTower.skillAttributes[skill].maxLevel) {
            incTower.skills.get(skill)().get('skillLevel')(incTower.skillAttributes[skill].maxLevel);
        }
        if (incTower.skillAttributes[skill].onMax !== undefined && incTower.skillIsMaxed(skill)) {
            incTower.skillAttributes[skill].onMax();
        }
        if (incTower.skillAttributes[skill].grants !== undefined) {
            var curLevel = incTower.getSkillLevel(skill);
            _.keys(incTower.skillAttributes[skill].grants).map(function (level) {
                if (curLevel >= level) {
                    toAdd = toAdd.concat(incTower.skillAttributes[skill].grants[level]);
                }
            });
        }
        //console.log(toAdd);
        _.map(toAdd, function (skill) {
            if (!incTower.haveSkill(skill)) {
                incTower.gainSkill(skill);
            }
        });
        incTower.skillTreeUpdateLabel(skill);
    };
    incTower.haveSkill = function (name) {
        return incTower.skills.get(name)() !== null;
    };
    incTower.getActiveSkillName = function () {
        var active = incTower.activeSkill();
        if (active in incTower.skillAttributes) {
            return incTower.skillAttributes[active].fullName;
        }
        return '';
    };
    incTower.skillRate = function () {
        return 1 + 0.1 * incTower.prestigePoints();
    };
    incTower.timeUntilSkillUp = function (pointDiff) {
        'use strict';
        return moment().add(pointDiff / incTower.skillRate(), 'seconds').fromNow();
    };

    incTower.skillDescribeTimeAdded = function (skill) {
        'use strict';
        var directlyQueueable = incTower.directlyQueueable(skill);
        if (directlyQueueable) {
            return moment().add(incTower.costCalc(incTower.skillAttributes[skill].baseCost, directlyQueueable, incTower.skillAttributes[skill].growth) / incTower.skillRate(), 'seconds').fromNow(true);
        }
    };
    incTower.calcSkill = function (skill,toLevel) {
        'use strict';
        var tally = new BigNumber(0);
        for (var i = 0; i < toLevel;i++) {
            tally = tally.plus(incTower.costCalc(incTower.skillAttributes[skill].baseCost,i,incTower.skillAttributes[skill].growth));
        }
        return tally;
    };
    incTower.calcSkillGrowth = function (skill,toLevel,targetTime) {
        'use strict';
        var toggle = 1;
        targetTime = new BigNumber(targetTime);
        while (1) {
            var baseGrowth = incTower.skillAttributes[skill].growth;
            var posGrowth = baseGrowth + toggle;
            var negGrowth = baseGrowth - toggle;
            var zeroval = calcSkill(skill,toLevel).minus(targetTime).abs();
            incTower.skillAttributes[skill].growth = posGrowth;
            var posval = calcSkill(skill,toLevel).minus(targetTime).abs();
            incTower.skillAttributes[skill].growth = negGrowth;
            var negval = calcSkill(skill,toLevel).minus(targetTime).abs();
            if (zeroval.lt(posval) && zeroval.lt(negval)) {
                console.log("Within " + zeroval.toJSON() + " at " + baseGrowth);
                if (zeroval.lt(1)) { break; }
                toggle /= 2;
            } else if (posval.lt(negval)) {
                console.log("Within " + posval.toJSON() + " at " + posGrowth);
                incTower.skillAttributes[skill].growth = posGrowth;
            } else {
                console.log("Within " + negval.toJSON() + " at " + negGrowth);
                incTower.skillAttributes[skill].growth = negGrowth;
            }
        }
    };
    incTower.secondsUntilSkillUp = ko.computed(function () {
        'use strict';
        if (this.skills.get(this.activeSkill())() === null) { return 0; }
        return this.skills.get(this.activeSkill())().get('skillPointsCap')().minus(this.skills.get(this.activeSkill())().get('skillPoints')());
    },incTower);
    incTower.secondsUntilQueueExhausted = ko.computed(function () {
        'use strict';
        if (this.skillQueue().length === 0) { return 0; }
        var tally = new BigNumber(0);
        _.forEach(this.skillQueue(), function (item) {
            var skill = item[0];
            var rank = item[1];
            if (incTower.haveSkill(skill) && incTower.getSkillLevel(skill) === rank - 1) {
                tally = tally.plus(incTower.skills.get(skill)().get('skillPointsCap')().minus(incTower.skills.get(skill)().get('skillPoints')()));
            } else {
                tally = tally.plus(incTower.costCalc(incTower.skillAttributes[skill].baseCost,rank,incTower.skillAttributes[skill].growth));
            }
        }, this);
        return tally;
    },incTower);
    incTower.percentageUntilSkillUp = ko.computed(function () {
        'use strict';
        if (this.skills.get(this.activeSkill())() === null) { return 0; }
        return this.skills.get(this.activeSkill())().get('skillPoints')().dividedBy(this.skills.get(this.activeSkill())().get('skillPointsCap')()).times(100);
    },incTower);
    incTower.skillTreeData = function () {
        var data = [];
        function addSkillToData (skill, parent) {
            if (parent === undefined) { parent = "#"; }
            var label = incTower.getSkillTreeLabel(skill);
            data.push({id: skill, parent: parent, text: label });
            if (incTower.skillAttributes[skill].grants !== undefined) {
                var origin = skill;
                _.map(incTower.possibleGrants(skill), function (skill) {
                    addSkillToData(skill, origin);
                });
            }
        }
        _.map(incTower.startingSkills,function (skill) { addSkillToData(skill); });
        return data;
    };
    incTower.skillTreeDataFlat = function () {
        var data = [];
        function addSkillToData (skill) {
            var currentLevel = '--';
            if (incTower.haveSkill(skill)) { currentLevel = incTower.getSkillLevel(skill); }
            var maxLevel = incTower.skillAttributes[skill].maxLevel;
            if (incTower.skillAttributes[skill].grants !== undefined) {
                _.map(incTower.possibleGrants(skill), function (skill) {
                    addSkillToData(skill);
                });
            }
            if (maxLevel !== undefined && currentLevel !== '--' && currentLevel === maxLevel) {
                return;
            }

            var label = incTower.getSkillTreeLabel(skill);
            data.push({id: skill, parent: '#', text: label });

        }
        _.map(incTower.startingSkills,function (skill) { addSkillToData(skill); });
        data = _.sortBy(data, ['text']);
        return data;
    };

    _.forEach(incTower.startingSkills, function (skill) {
        if (!incTower.haveSkill(skill)) {
            incTower.gainSkill(skill);
        }
    });

});
